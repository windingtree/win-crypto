{
  "language": "Solidity",
  "sources": {
    "contracts/Asset.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Manageable} from './Manageable.sol';\nimport {Permit} from './libraries/Permit.sol';\nimport {LedgerLike, WrappedErc20Like} from './interfaces/Common.sol';\n\ncontract Asset is Manageable {\n  /// @dev Reference to Ledger contract\n  LedgerLike public ledger;\n\n  /// @dev Reference to asset contract\n  WrappedErc20Like public asset;\n\n  /// @dev Flag if the asset is wrapped\n  uint256 public wrapped;\n\n  // --- errors\n\n  /// @dev Throws when uint265 value overflow\n  error UintOverflow();\n\n  /// @dev Throws when transfer is failed\n  error TransferFailed(address src, address dst, address asset, uint256 value);\n\n  /// @dev Throws when called wrapped associated function on the non-wrapped asset\n  error NonWrappedAsset();\n\n  /// @dev Throws when invalid value provided\n  error InvalidValue();\n\n  // --- events\n\n  /// @dev Emitted when asset joined\n  event Join(address src, uint256 value);\n\n  /// @dev Emitted when asset has been withdrawn\n  event Exit(address dst, uint256 value);\n\n  constructor(\n    address _ledger,\n    address _asset,\n    uint256 _wrapped\n  ) {\n    auth[msg.sender] = 1;\n    live = 1;\n    ledger = LedgerLike(_ledger);\n    wrapped = _wrapped;\n    asset = WrappedErc20Like(_asset);\n    emit Rely(msg.sender);\n  }\n\n  function _join(\n    address src,\n    address dst,\n    uint256 value\n  ) internal {\n    if (int256(value) < 0) {\n      revert UintOverflow();\n    }\n    ledger.add(dst, address(asset), int256(value));\n    if (src != address(this)) {\n      if (!asset.transferFrom(src, address(this), value)) {\n        revert TransferFailed(src, dst, address(asset), value);\n      }\n    }\n    emit Join(dst, value);\n  }\n\n  /// @dev Joins ERC20 compatible assets directly from sender\n  /// @param dst Asset destination address (balance owner)\n  /// @param value Asset value\n  function join(address dst, uint256 value) external onlyLive {\n    _join(msg.sender, dst, value);\n  }\n\n  /// @dev Joins ERC20 compatible assets directly from known address\n  /// @param src Asset owner address\n  /// @param dst Asset destination address (balance owner)\n  /// @param value Asset value\n  function join(\n    address src,\n    address dst,\n    uint256 value\n  ) external onlyLive {\n    _join(src, dst, value);\n  }\n\n  /// @dev Joins ERC20 compatible assets directly from known address with permit\n  /// @param src Asset owner address\n  /// @param dst Asset destination address (balance owner)\n  /// @param value Asset value\n  function join(\n    address src,\n    address dst,\n    uint256 value,\n    Permit.EIP2612Permit calldata permit\n  ) external onlyLive {\n    asset.permit(src, address(this), value, permit.deadline, permit.v, permit.r, permit.s);\n    _join(src, dst, value);\n  }\n\n  /// @dev Joins ERC20 compatible assets directly from sender\n  /// @param dst Asset destination address (balance owner)\n  /// @param value Asset value\n  function joinWrapped(address dst, uint256 value) external payable onlyLive {\n    if (wrapped == 0) {\n      revert NonWrappedAsset();\n    }\n    if (msg.value != value) {\n      revert InvalidValue();\n    }\n    asset.deposit{value: msg.value}();\n    _join(address(this), dst, value);\n  }\n\n  /// @dev Withdraws funds\n  /// @param dst Asset destination address (balance owner)\n  /// @param value Asset value\n  function exit(address dst, uint256 value) external onlyLive {\n    if (value > 2**255) {\n      revert UintOverflow();\n    }\n    ledger.add(msg.sender, address(asset), -int256(value));\n    if (!asset.transfer(dst, value)) {\n      revert TransferFailed(address(this), dst, address(asset), value);\n    }\n    emit Exit(dst, value);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/Manageable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nabstract contract Manageable {\n  /// @dev Active flag\n  uint256 public live;\n\n  /// @dev Authorized parties\n  mapping(address => uint256) public auth;\n\n  // -- errors\n\n  /// @dev Throws if the contract called when it is not live\n  error NotLive();\n\n  /// @dev Throws when action is not authorized\n  error NotAuthorized();\n\n  // -- events\n\n  /// @dev Emitted when the contract live flag is changed\n  event Live(uint256 live);\n\n  /// @dev Emitted when a party is authorized\n  event Rely(address party);\n\n  /// @dev Emitted when a party is denied\n  event Deny(address party);\n\n  // --- modifiers\n\n  /// @dev Checks if the sender is authorized\n  modifier authorized() {\n    if (auth[msg.sender] != 1) {\n      revert NotAuthorized();\n    }\n    _;\n  }\n\n  /// @dev Checks is the contract live\n  modifier onlyLive() {\n    if (live == 0) {\n      revert NotLive();\n    }\n    _;\n  }\n\n  // --- admin\n\n  /// @dev Toggles the contract live flag\n  function toggle() external authorized {\n    if (live == 1) {\n      live = 0;\n    } else {\n      live = 1;\n    }\n    emit Live(live);\n  }\n\n  /// @dev Adds authorized party\n  function rely(address party) external authorized {\n    auth[party] = 1;\n    emit Rely(party);\n  }\n\n  /// @dev Removes authorized party\n  function deny(address party) external authorized {\n    auth[party] = 0;\n    emit Deny(party);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/libraries/Permit.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nlibrary Permit {\n  struct EIP2612Permit {\n    address owner;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n}\n"
    },
    "contracts/interfaces/Common.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Permit} from '../libraries/Permit.sol';\n\ninterface LedgerLike {\n  function balances(address dst, address asset) external returns (uint256);\n\n  function add(\n    address,\n    address,\n    int256\n  ) external;\n\n  function move(\n    address src,\n    address dst,\n    address asset,\n    uint256 value\n  ) external;\n}\n\ninterface Erc20Like {\n  function decimals() external view returns (uint256);\n\n  function transfer(address, uint256) external returns (bool);\n\n  function transferFrom(\n    address,\n    address,\n    uint256\n  ) external returns (bool);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\ninterface WrappedErc20Like is Erc20Like {\n  function balanceOf(address) external returns (uint256);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n}\n\ninterface AssetLike {\n  function ledger() external returns (address);\n\n  function asset() external returns (address);\n\n  function wrapped() external returns (uint256);\n\n  function join(address dst, uint256 value) external;\n\n  function join(\n    address src,\n    address dst,\n    uint256 value\n  ) external;\n\n  function join(\n    address src,\n    address dst,\n    uint256 value,\n    Permit.EIP2612Permit memory permit\n  ) external;\n\n  function joinWrapped(address dst, uint256 value) external payable;\n\n  function exit(address dst, uint256 value) external;\n}\n"
    },
    "contracts/upgradeable/AssetUpgradeableV1.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Asset} from '../Asset.sol';\nimport {LedgerLike, WrappedErc20Like} from '../interfaces/Common.sol';\nimport {Upgradeable} from './Upgradeable.sol';\n\ncontract AssetUpgradeableV1 is Upgradeable, Asset {\n  constructor(\n    address _ledger,\n    address _asset,\n    uint256 _wrapped\n  ) Asset(_ledger, _asset, _wrapped) {}\n\n  function postUpgrade(\n    address _ledger,\n    address _asset,\n    uint256 _wrapped\n  ) public onlyUpgrader {\n    auth[msg.sender] = 1;\n    live = 1;\n    ledger = LedgerLike(_ledger);\n    wrapped = _wrapped;\n    asset = WrappedErc20Like(_asset);\n    emit Rely(msg.sender);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/upgradeable/Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nabstract contract Upgradeable {\n  address public upgrader;\n\n  /// @dev Throws when function called not by upgrader\n  error NotUpgrader();\n\n  /// @dev Checks is the caller is upgrader\n  modifier onlyUpgrader() {\n    if (upgrader == address(0)) {\n      upgrader = msg.sender;\n    }\n    if (msg.sender != upgrader) {\n      revert NotUpgrader();\n    }\n    _;\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/upgradeable/WinPayUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {WinPay} from '../WinPay.sol';\nimport {Upgradeable} from './Upgradeable.sol';\nimport {LedgerLike} from '../interfaces/Common.sol';\n\ncontract WinPayUpgradeable is Upgradeable, WinPay {\n  constructor(address _ledger) WinPay(_ledger) {}\n\n  function postUpgrade(address _ledger) public onlyUpgrader {\n    auth[msg.sender] = 1;\n    live = 1;\n    ledger = LedgerLike(_ledger);\n    emit Rely(msg.sender);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/WinPay.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Manageable} from './Manageable.sol';\nimport {Permit} from './libraries/Permit.sol';\nimport {AssetLike, WrappedErc20Like, LedgerLike} from './interfaces/Common.sol';\n\ncontract WinPay is Manageable {\n  enum State {\n    UNINITIALIZED,\n    PAID,\n    REFUNDED\n  }\n\n  struct DealStorage {\n    bytes32 provider;\n    address customer;\n    address asset;\n    uint256 value;\n    State state;\n  }\n\n  /// @dev Reference to Ledger contract\n  LedgerLike public ledger;\n\n  /// @dev Service providers registry\n  mapping(bytes32 => address) public providers; // provider => EOA\n\n  /// @dev Deals registry\n  mapping(bytes32 => DealStorage) public deals; // serviceId => DealStorage\n\n  // -- errors\n\n  /// @dev Throws when provider is already registered\n  error ProviderExists();\n\n  /// @dev Throws when provider not found\n  error ProviderNotFound(bytes32 provider);\n\n  /// @dev Throws when the deal is already initialized\n  error DealExists(bytes32 serviceId);\n\n  /// @dev Throws when the deal not found\n  error DealNotFound(bytes32 serviceId);\n\n  /// @dev Throws when the deal is expired\n  error DealExpired(bytes32 serviceId, uint256 expiry);\n\n  /// @dev Throws when the deal is already refunded\n  error DealAlreadyRefunded(bytes32 serviceId);\n\n  /// @dev Throws when invalid value provided\n  error InvalidValue();\n\n  /// @dev Throws when balance not enough for payment\n  error BalanceNotEnough();\n\n  // -- events\n\n  /// @dev Emitted when the provider is registered or changed\n  event Provider(bytes32 provider, address wallet);\n\n  /// @dev Emitted when deal is occurred\n  event Deal(bytes32 provider, bytes32 serviceId);\n\n  /// @dev Emitted when deal is refunded\n  event Refund(bytes32 provider, bytes32 serviceId);\n\n  constructor(address _ledger) {\n    auth[msg.sender] = 1;\n    live = 1;\n    ledger = LedgerLike(_ledger);\n    emit Rely(msg.sender);\n  }\n\n  /// @dev Register a new provider\n  /// @param provider Unique provider Id\n  /// @param wallet Provider's wallet\n  function register(bytes32 provider, address wallet) external onlyLive {\n    if (providers[provider] != address(0)) {\n      revert ProviderExists();\n    }\n    providers[provider] = wallet;\n    emit Provider(provider, wallet);\n  }\n\n  /// @dev Update the provider\n  /// @param provider Unique provider Id\n  /// @param wallet Provider's wallet\n  function updateProvider(bytes32 provider, address wallet) external onlyLive {\n    if (msg.sender != providers[provider]) {\n      revert NotAuthorized();\n    }\n    providers[provider] = wallet;\n    emit Provider(provider, wallet);\n  }\n\n  // --- deals\n\n  /// @dev Makes a deal\n  /// @param provider Unique provider Id\n  /// @param serviceId Unique service Id\n  /// @param expiry The timestamp at which the deal is no longer valid\n  /// @param asset The address of the proper Asset implementation\n  /// @param permit Data required for making of payment with tokens using permit\n  function _deal(\n    bytes32 provider,\n    bytes32 serviceId,\n    uint256 expiry,\n    address asset,\n    uint256 value,\n    Permit.EIP2612Permit memory permit\n  ) internal onlyLive {\n    // make sure provider registered\n    if (providers[provider] == address(0)) {\n      revert ProviderNotFound(provider);\n    }\n\n    DealStorage storage dealStorage = deals[serviceId];\n\n    // make sure the deal has not been created before\n    if (dealStorage.state != State.UNINITIALIZED) {\n      revert DealExists(serviceId);\n    }\n\n    // make sure the deal is not expired\n    if (expiry < block.timestamp) {\n      revert DealExpired(serviceId, expiry);\n    }\n\n    AssetLike assetInstance = AssetLike(asset);\n    address assetAddress = assetInstance.asset();\n\n    // when asset is `wrapped` we should try to `wrap` native tokens\n    if (assetInstance.wrapped() > 0 && msg.value > 0) {\n      if (msg.value != value) {\n        revert InvalidValue();\n      }\n      assetInstance.joinWrapped{value: msg.value}(providers[provider], value);\n    } else if (permit.owner != address(0)) {\n      // we have a permission from the customer, so, use it\n      assetInstance.join(msg.sender, providers[provider], value, permit);\n    } else {\n      // normal asset joining\n      assetInstance.join(msg.sender, providers[provider], value);\n    }\n\n    dealStorage.provider = provider;\n    dealStorage.customer = msg.sender;\n    dealStorage.asset = assetAddress;\n    dealStorage.value = value;\n    dealStorage.state = State.PAID;\n\n    emit Deal(provider, serviceId);\n  }\n\n  // `deal` version without `permit` functionality\n  function deal(\n    bytes32 provider,\n    bytes32 serviceId,\n    uint256 expiry,\n    address asset,\n    uint256 value\n  ) external payable onlyLive {\n    _deal(provider, serviceId, expiry, asset, value, Permit.EIP2612Permit(address(0), 0, 0, bytes32(0), bytes32(0)));\n  }\n\n  // `deal` version with `permit`\n  function deal(\n    bytes32 provider,\n    bytes32 serviceId,\n    uint256 expiry,\n    address asset,\n    uint256 value,\n    Permit.EIP2612Permit memory permit\n  ) external onlyLive {\n    _deal(provider, serviceId, expiry, asset, value, permit);\n  }\n\n  /// @dev Refunds a deal\n  /// @param serviceId Unique service Id\n  /// @param asset The Asset contract reference\n  function refund(bytes32 serviceId, address asset) external onlyLive {\n    DealStorage storage dealStorage = deals[serviceId];\n\n    // make sure the deal is exists\n    if (dealStorage.state == State.UNINITIALIZED) {\n      revert DealNotFound(serviceId);\n    }\n\n    // make sure function called by the proper provider\n    if (msg.sender != providers[dealStorage.provider]) {\n      revert NotAuthorized();\n    }\n\n    // make sure the deal has not been refunded\n    if (dealStorage.state == State.REFUNDED) {\n      revert DealAlreadyRefunded(serviceId);\n    }\n\n    // check provider's balance\n    if (ledger.balances(providers[dealStorage.provider], dealStorage.asset) < dealStorage.value) {\n      revert BalanceNotEnough();\n    }\n\n    // finalize the deal state\n    dealStorage.state = State.REFUNDED;\n\n    // take funds from the providers' account to the WinPay contract\n    ledger.move(providers[dealStorage.provider], address(this), dealStorage.asset, dealStorage.value);\n    // ...and send them to the customer\n    AssetLike(asset).exit(dealStorage.customer, dealStorage.value);\n\n    emit Refund(dealStorage.provider, serviceId);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/Ledger.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Manageable} from './Manageable.sol';\n\ncontract Ledger is Manageable {\n  /// @dev Balances\n  mapping(address => mapping(address => uint256)) public balances; // EOA => asset address => balance\n\n  constructor() {\n    auth[msg.sender] = 1;\n    live = 1;\n    emit Rely(msg.sender);\n  }\n\n  /// @dev Adds or subtract value of the asset\n  /// @param dest Balance owner address\n  /// @param asset Asset contract address\n  /// @param value Asset value\n  function add(\n    address dest,\n    address asset,\n    int256 value\n  ) external onlyLive authorized {\n    balances[dest][asset] = _add(balances[dest][asset], value);\n  }\n\n  /// @dev Move balance from the source to destination\n  /// @param src Balance owner address\n  /// @param dest Destination address\n  /// @param asset Asset contract address\n  /// @param value Asset value\n  function move(\n    address src,\n    address dest,\n    address asset,\n    uint256 value\n  ) external onlyLive authorized {\n    balances[src][asset] = _add(balances[src][asset], -int256(value));\n    balances[dest][asset] = _add(balances[dest][asset], int256(value));\n  }\n\n  // --- helpers\n  function _add(uint256 x, int256 y) internal pure returns (uint256 z) {\n    unchecked {\n      z = x + uint256(y);\n      require(y >= 0 || z <= x);\n      require(y <= 0 || z >= x);\n    }\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/upgradeable/LedgerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Ledger} from '../Ledger.sol';\nimport {Upgradeable} from './Upgradeable.sol';\n\ncontract LedgerUpgradeable is Upgradeable, Ledger {\n  constructor() Ledger() {}\n\n  function postUpgrade() public onlyUpgrader {\n    auth[msg.sender] = 1;\n    live = 1;\n    emit Rely(msg.sender);\n  }\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/upgradeable/AssetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {ExitSelfable} from '../ExitSelfable.sol';\nimport {AssetUpgradeableV1} from './AssetUpgradeableV1.sol';\n\ncontract AssetUpgradeable is AssetUpgradeableV1, ExitSelfable {\n  constructor(\n    address _ledger,\n    address _asset,\n    uint256 _wrapped\n  ) AssetUpgradeableV1(_ledger, _asset, _wrapped) {}\n\n  function postUpgrade() public onlyUpgrader {}\n\n  uint256[50] private __gap;\n}\n"
    },
    "contracts/ExitSelfable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity ^0.8.13;\n\nimport {Asset} from './Asset.sol';\n\nabstract contract ExitSelfable is Asset {\n\n  /// @dev Withdraws self owned funds\n  /// @param dst Asset destination address (balance owner)\n  function exitSelf(address dst) external authorized {\n    uint256 selfBalance = asset.balanceOf(address(this));\n    if (!asset.transfer(dst, selfBalance)) {\n      revert TransferFailed(address(this), dst, address(asset), selfBalance);\n    }\n  }\n\n  uint256[50] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}